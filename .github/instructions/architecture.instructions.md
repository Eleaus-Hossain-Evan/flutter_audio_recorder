---
description: "Clean Architecture folder structure and project organization. Load when creating new features, understanding codebase structure, setting up domain/infrastructure/application/presentation layers, deciding where to place new files, implementing repository pattern, or discussing dependency flow between layers."
---

# Project Architecture (Simplified Clean Architecture)

## Overview

This project follows a **simplified Clean Architecture** with clear separation of concerns. The codebase is organized into two main areas:

- **`lib/features/`** — Feature modules (vertical slices)
- **`lib/core/`** — Shared infrastructure and utilities

## Feature Structure

Each feature is a self-contained module with 4 layers:

```
lib/features/<feature_name>/
├── application/       # State management (Riverpod providers)
├── domain/            # Business contracts (interfaces, models)
│   ├── i_<name>_repo.dart
│   └── models/
├── infrastructure/    # Data layer (repository implementations)
├── presentation/      # UI layer (pages, widgets)
│   └── widgets/
└── utils/             # (optional) Feature-specific helpers
```

### Layer Responsibilities

| Layer              | Contains                                      | Depends On                  |
| ------------------ | --------------------------------------------- | --------------------------- |
| **Domain**         | Interfaces (`I*Repo`), Models, Response types | Nothing (innermost)         |
| **Infrastructure** | Repository implementations                    | Domain, Core/Network        |
| **Application**    | Riverpod providers, State notifiers           | Domain, Infrastructure      |
| **Presentation**   | Pages, Widgets                                | Application (via providers) |

### Dependency Rule

```
Presentation → Application → Infrastructure → Domain
                                    ↓
                                  Core
```

- Inner layers know nothing about outer layers
- Domain is pure Dart (no Flutter, no external dependencies)
- Infrastructure depends on Domain interfaces
- Application wires everything together via providers

---

## Domain Layer

The **domain** layer defines the business contracts.

### Interface Pattern

```dart
// lib/features/auth/domain/i_auth_repo.dart
abstract interface class IAuthRepo {
  Future<AuthResponse> signIn({required String phone, required String password});
  Future<AuthResponse> signUp({required String name, required String phone, ...});
  Future<bool> signOut();
}
```

**Conventions:**

- File: `i_<name>_repo.dart` (prefix `i_`)
- Class: `I<Name>Repo` (prefix `I`)
- Use `abstract interface class` (Dart 3+)
- Return typed response models, not raw data
- Use named parameters with `required`

### Models

```dart
// lib/features/auth/domain/models/user_model.dart
class UserModel extends Equatable {
  final String id;
  final String name;
  final String email;

  const UserModel({required this.id, required this.name, required this.email});

  // Generated by Dart Data Class Generator:
  // copyWith(), toMap(), fromMap(), toJson(), fromJson(), toString(), props
}
```

**Conventions:**

- File: `<name>_model.dart`
- Extend `Equatable` for value equality
- All fields `final` with `const` constructor
- Models are immutable data containers

### Response Wrappers

```dart
// lib/features/auth/domain/auth_response.dart
class AuthResponse extends Equatable {
  final bool success;
  final String message;
  final UserModel? data;

  const AuthResponse({required this.success, required this.message, this.data});

  factory AuthResponse.fromMap(Map<String, dynamic> map) => AuthResponse(
    success: map['success'] ?? false,
    message: map['message'] ?? '',
    data: map['data'] != null ? UserModel.fromMap(map['data']) : null,
  );
}
```

---

## Infrastructure Layer

The **infrastructure** layer implements domain interfaces.

### Repository Implementation

```dart
// lib/features/auth/infrastructure/auth_repo.dart
class AuthRepoImpl implements IAuthRepo {
  final Dio _dio;
  final ILocalStorageService _storage;

  AuthRepoImpl(this._dio, this._storage);

  @override
  Future<AuthResponse> signIn({required String phone, required String password}) async {
    final response = await DioService.run(
      request: () => _dio.post(ApiEndpoint.signin, data: {
        'phone': phone,
        'password': password,
      }),
      parse: (data) => AuthResponse.fromMap(data),
    );

    // Side effects (caching, token storage)
    if (response.success && response.data != null) {
      await _storage.saveToken(response.data!.token);
    }

    return response;
  }
}
```

**Conventions:**

- File: `<name>_repo.dart` (no `i_` prefix)
- Class: `<Name>RepoImpl` (suffix `Impl`)
- Dependencies injected via constructor
- Use `DioService.run()` for all API calls
- Handle side effects (caching, storage) here

---

## Application Layer

The **application** layer manages state with Riverpod.

### Repository Provider

```dart
// lib/features/auth/application/auth_provider.dart
@riverpod
IAuthRepo authRepo(Ref ref) {
  return AuthRepoImpl(
    ref.watch(dioClientProvider),
    ref.watch(tokenStorageProvider),
  );
}
```

**Key:** Return interface type (`IAuthRepo`), not implementation.

### State Notifier Provider

```dart
@riverpod
class Auth extends _$Auth {
  @override
  FutureOr<UserModel?> build() async {
    final storage = ref.watch(tokenStorageProvider);
    final token = await storage.getToken();
    if (token != null) {
      return ref.watch(authRepoProvider).getCurrentUser();
    }
    return null;
  }

  Future<({bool success, String? errorMessage})> signIn({
    required String phone,
    required String password,
  }) async {
    state = const AsyncLoading();

    final result = await ref.read(authRepoProvider).signIn(
      phone: phone,
      password: password,
    );

    if (result.success && result.data != null) {
      state = AsyncData(result.data);
      return (success: true, errorMessage: null);
    }

    state = AsyncError(result.message, StackTrace.current);
    return (success: false, errorMessage: result.message);
  }
}
```

### Provider Types Summary

| Type       | Annotation                      | Use Case                             |
| ---------- | ------------------------------- | ------------------------------------ |
| Simple     | `@riverpod`                     | Factory for repos, computed values   |
| Persistent | `@Riverpod(keepAlive: true)`    | State that survives disposal         |
| Notifier   | `@riverpod class X extends _$X` | Stateful with methods                |
| Override   | `@Riverpod(dependencies: [])`   | Passed via `ProviderScope.overrides` |

---

## Presentation Layer

The **presentation** layer contains UI components.

### Page Structure

```dart
// lib/features/auth/presentation/login_page.dart
class LoginPage extends HookConsumerWidget {
  const LoginPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // Local state with hooks
    final phoneController = useTextEditingController();
    final formKey = useMemoized(() => GlobalKey<FormState>());

    // Watch provider state
    final authState = ref.watch(authProvider);

    // Listen for side effects
    ref.listen(authProvider, (previous, next) {
      next.whenOrNull(
        data: (user) => context.go('/home'),
        error: (error, _) => context.showErrorToast(error.toString()),
      );
    });

    return Scaffold(
      body: Form(
        key: formKey,
        child: // ... UI
      ),
    );
  }
}
```

**Conventions:**

- File: `<name>_page.dart` for pages
- Use `HookConsumerWidget` for pages (hooks + Riverpod)
- Use `ConsumerWidget` for simple widgets
- `ref.watch()` for reactive state
- `ref.listen()` for navigation/toasts
- `ref.read()` in callbacks only

### Widgets Folder

Feature-specific widgets go in `presentation/widgets/`:

```
presentation/
├── login_page.dart
├── register_page.dart
└── widgets/
    ├── custom_text_field.dart
    ├── login_header_widget.dart
    └── social_login_button.dart
```

---

## Core Module Structure

Shared infrastructure lives in `lib/core/`:

```
lib/core/
├── core.dart              # Barrel export
├── flavor/                # Environment configuration
├── models/                # Shared/generic models
├── network/               # HTTP client, interceptors
│   ├── api_endpoint.dart
│   ├── dio_client.dart
│   ├── dio_service.dart
│   └── app_exception.dart
├── router/                # GoRouter configuration
├── storage/               # Local persistence
├── theme/                 # Visual styling
├── utils/                 # Helpers, extensions, constants
└── widgets/               # Reusable UI components
```

### Core vs Feature Decision Guide

| Put in **Core** if...  | Put in **Feature** if... |
| ---------------------- | ------------------------ |
| Used by 2+ features    | Specific to one feature  |
| App-wide configuration | Feature-specific logic   |
| Generic utilities      | Feature models/repos     |
| Shared UI components   | Feature pages/widgets    |

---

## File Naming Conventions

| Type           | Pattern                | Example                      |
| -------------- | ---------------------- | ---------------------------- |
| Interface      | `i_<name>_repo.dart`   | `i_auth_repo.dart`           |
| Implementation | `<name>_repo.dart`     | `auth_repo.dart`             |
| Provider       | `<name>_provider.dart` | `auth_provider.dart`         |
| Model          | `<name>_model.dart`    | `user_model.dart`            |
| Response       | `<name>_response.dart` | `auth_response.dart`         |
| Page           | `<name>_page.dart`     | `login_page.dart`            |
| Barrel export  | `<folder>.dart`        | `network.dart`, `theme.dart` |
| Generated      | `*.g.dart`             | `auth_provider.g.dart`       |

---

## Creating a New Feature

1. **Create folder structure:**

   ```
   lib/features/my_feature/
   ├── application/
   ├── domain/
   │   └── models/
   ├── infrastructure/
   └── presentation/
       └── widgets/
   ```

2. **Define interface** in `domain/i_my_feature_repo.dart`

3. **Create models** in `domain/models/`

4. **Implement repository** in `infrastructure/my_feature_repo.dart`

5. **Create providers** in `application/my_feature_provider.dart`

6. **Build UI** in `presentation/`

7. **Run code generation:**
   ```bash
   dart run build_runner build --delete-conflicting-outputs
   ```

---

## Import Guidelines

```dart
// ✅ Features can import from core
import 'package:dhks/core/core.dart';
import 'package:dhks/core/network/network.dart';

// ✅ Presentation imports from application
import '../application/auth_provider.dart';

// ❌ Avoid cross-feature imports
// import 'package:dhks/lib/features/other_feature/...';

// ❌ Domain should not import Flutter
// import 'package:flutter/material.dart'; // in domain layer
```

---

## Barrel Exports

Each module has a barrel file exporting public APIs:

```dart
// lib/core/core.dart
export 'theme/theme.dart';
export 'utils/utils.dart';
export 'widgets/widgets.dart';

// lib/core/network/network.dart
export 'api_endpoint.dart';
export 'dio_client.dart';
export 'dio_service.dart';
```

Use barrel imports for cleaner code:

```dart
// Instead of multiple imports
import 'package:dhks/core/network/dio_client.dart';
import 'package:dhks/core/network/api_endpoint.dart';

// Use barrel import
import 'package:dhks/core/network/network.dart';
```
